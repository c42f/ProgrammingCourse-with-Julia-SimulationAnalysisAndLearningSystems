# Unit 4: More language features for software architecture

In the previous three units we explored basics of programming and computation (Unit 1), algorithms and data structures (Unit 2), and data files and numerics (Unit 3). In this unit we take a deeper and more thorough approach at basic Julia language features. 

Programming languages, including Julia, are designed mostly with these aims in mind:

 1. **Execution speed** — programs should run fast enough to solve the problem at hand. 
 2. **Coding speed** — writing programs to solve problems should be quick & easy for the coder.
 3. **Scalable engineering** — creating and maintaining large programs with many contributors should be no harder than writing small programs yourself.

Different programming languages have different goals and target audiences, and make different trade-offs and affordances for the above. The trickiest one to get right is the third one — as codebases grow it is _typical_ to get stuck in a tarpit of complexity, where it gets harder and harder to change and improve the code, and progress grinds to a halt. A corollary of that is that code in large pieces of software is _read_ far more often than it is _written_, so it becomes crucial to make code that is written easy to understand.

Julia is a high-performance language for solving large mathematical problems, and compiled code needs to run "close to the metal". It makes many affordances to solve mathematical problems quickly and efficiently. But most crucially, it tries to solve these in such a way that is "scalable" — where generic code can be reused and repurposed, and pieces of a program can be connected together elegantly like lego bricks.

The goal of this unit is to show you the most important language features of Julia and how to use them to best effect. The most important language features that we explore are the syntax, type system, user-defined types, and multiple-dispatch. At the end we'll consider how to use these to construct your code. The notes below often refer to the Julia documentation.

## Values and their types

One way Julia allows for easy and fast mathematical code is to emphasise _values_ (or _objects_), and transformations of values (via functions).

A few ways that is apparent is:

 1. All valid Julia code is an _expression_ that evaluates to a value (no statements, no `void`).
 2. Every value has a specific (or "concrete") _type_ (like `String` or `Int64`).
 3. Functions are values, which can be stored in variables or passed to other functions.

Many modern languages feature the above, but Julia takes it even further than that:

 4. Types are also values that can be passed around and manipulated.
 5. Julia code is a value (you can use and create macros, access generated native code, etc).

With these last two, you can do some pretty powerful things with Julia. In fact, most of Julia is itself written in Julia. However, we won't focus on those here.

### Why is it so?

Remember, all this is designed to make it easy for mathematicians to write code that fast to run and easy to scale.

In mathematics, we are interested in values or objects, as well as operations and transformations on such objects. Basing the language around values (objects), and allowing functions to behave like values (objects), makes our code resemble mathematics and have a similar interpretation. It does this without "getting in your way" or stopping you writing imperative code.

The fact that values have _types_ is for two reasons:

 1. Types let us specify our data and define the _behavior_ of functions that operator on them (using multiple dispatch).
 2. Types let the compiler know the _representation_ of the value in memory (e.g. how many bytes it is) so it can generate fast code.

Types have two purposes: help _humans_ organise their data and define behaviour, and the help _the computer_ to execute the program quickly.

### All valid code is an _expression_

An expression is a piece of code that evaluates to a value. (Some languages, like Python or C, also have other pieces of syntax which are not expressions, typically known as "statements" - a statement tells to computer or compiler to "do something" but does not produce a value you can use).

Here are some expressions in Julia:

```julia
1 + 1
["a", "b", "c"]
println(pi)
```

One nice aspects of expressions is you can copy them and paste them anywhere that expects an expression, and it is guaranteed to by syntactically valid. Each of these expressions evaluate to a value, which you can for example bind to a variable:

```julia
x = 1 + 1
y = ["a", "b", "c"]
z = println(pi)
```

### Every value has a concrete type

The types of the first value is straightforward:

```julia
typeof(1+1)
```

This is just a 64-bit signed integer, which requires 64 bits (or 8 bytes) of memory to represent at runtime.

The second is a 1D array, or vector:

```
typeof(["a", "b", "c"])
```

Vectors can be arbitrarily long and use an unknown amount of memory at runtime. We'll talk about type parameters (the `{String}` part) and aliases in more detail later, but first let's look at the third:

```julia
typeof(println(pi))
```

The `println` function takes input and prints it to the console (followed by a new line). It doesn't really have any "value" to return. But I said earlier that all expressions in Julia return _some_ value. Julia has an value defined called `nothing` for this purpose, which is of type `Nothing`. There is nothing special about this type, except that it has no associated data (meaning it needs 0 bytes of data to represent at runtime).

### What is a concrete type?

A type can be thought of as a set of values.

Every value is a concrete type, and Julia has just these concrete types:

 1. `primitive type`
 2. `struct` (and `mutable struct`)
 3. `Array{N, T}` (and `Vector{T}` / `Matrix{T}`)
 4. `String`

### Primitive types

Primitive types is where we begin describing data at the bits-and-bytes level. Here is the definition of `UInt8`:

```julia; eval = false
primitive type UInt8
    8
end
```

There are 256 possible `UInt8` values: `0x00, 0x01, ..., 0xfe, 0xff`. You could say `UInt8` is a set with 256 elements.

Here are the definitions of `Int64` and `Float64`:

```julia; eval = false
primitive type Int64
    64
end

primitive type Float64
    64
end
```

Each of these are sets containing `2^64` (about `10^18`) possible values. However, for every value in your program Julia keeps track of the type of the value, as well as the data. You can consider `Int64` and `Float64` to be _disjoint_ sets. The values `0` (an integer) and `0.0` (a float) are represented by exactly the same bits (all zero), yet they are not "the same":

```julia
reinterpret(Float64, 0)
```

```julia
reinterpret(Int64, 0.0)
```

```julia
0 === 0.0
```

(Type tracking typically occurs at compile time, before the program runs, so Julia doesn't need to store extra data describing whether every value is an integer or a float or something else.)

The advantage of distinct types is we can describe different behavour for these types. For example, there are seperate methods for addition representing the different ways the CPU handles integer and floating-point arithmetic, `+(x::Int64, y::Int64)` and `+(x::Float64, y::Float64)`.

(Note that all primitive types are immutable values. You cannot "mutate" `0` to become `1` - you construct a new value instead.)

### Structs

Structs allow us to organise different pieces of data into a "structure". In general, structs represent composition of data: e.g. a complex number consists of a real component and an imaginary component:

```julia
struct Complex64
    re::Float64
    im::Float64
end
```

The compiler knows that a `Complex64` needs 128 bits of data to represent - 64 bits each for `re` and `im`. This type is a distinct set with `2^128` possible values. 

You can construct a struct with the "constructor" - where the type doubles as a kind of function that lets you specify the fields:

```julia
z = Complex64(1.0, 2.0)
```

```julia
sizeof(z)
```

You can get a field from the struct with the `.` operator, for example 

```julia
z.re
```

```julia
z.im
```

#### Empty structs

A struct can have any number of fields, including zero:

```julia; eval = false
struct Nothing
end

const nothing = Nothing()
```

This is exactly how `nothing` is defined in Julia! It takes zero bytes to represent nothing, and you could say `Nothing` is like a set containing `2^0 = 1` possible value - `nothing`.

##### Mutable structs

By default structs are immutable - once constructed you cannot edit the fields. It is possible to create structs that you can modify with the `mutable` keyword:

```julia; eval = false
mutable struct MutableComplex64
   re::Float64
   im::Float64
end

z = MutableComplex64(1.0, 2.0)

z.im = 0.0  # this would throw an error if z were immutable
```

#### Generic structs

Finally, one more thing you can do is create _generic_ structs. In Julia the type for complex numbers is more like:

```julia
struct Complex{T}
    re::T
    im::T
end
```

Given some type `T`, `Complex{T}` is a struct with fields `re` and `im` of type `T`. 

This useful because now we don't need a seperate `struct` definition for complex numbers with `Float32` components, or `Int64` components, or whatever. Just one definition suffices for them all. This lets us write quite generic code that is oblivious to the exact type `T` but uses properties common to all complex numbers. For example, the absolute value squared can be written:

```julia
function abs2(z::Complex)
    return z.re*z.re + z.im*z.im
end
```

and this single definition is sufficient for all possible `T`.

Note that the type `Complex` is an _abstract_ type (not a _concrete_ type). We'll talk more about abstract types and multiple dispatch later. For now, note that Julia lets you write both generic data types and generic functions.

#### Type aliases

Earlier we saw an example of a type "alias". You can create them like so:

```julia; eval = false
const Complex64 = Complex{Float64}
```

Type aliases are useful to make your code shorter or more readable.

#### Tuples

Tuples in Julia are a kind of "lightweight" struct with no type or fieldnames that you need to define in advance. You construct tuples with brackets like `(1, 2, 3)`. Note the types don't have to be uniform, `t = (1, true, "abc")` is equally valid. You access the fields with the index, such as `t[3] === "abc"`.

Note the syntax of tuples is much like the arguments to a function - `(x, y)` is a tuple and `f(x, y)` calls function `f` with inputs `(x, y)`. The correspondence is intentional.

Julia also has "named" tuples, where you can name the fields, like `(a = 1, b = true, c = "abc")`. (These look a bit like keyword arguments to functions).

### Arrays

Structs are useful for collecting data, but only if you know how many elements you want at compile time.

Arrays are dynamically-sized collections, that can contain zero-or-more elements. We use arrays a lot in Julia.

Arrays in Julia are multi-dimensional and have the type `Array{T, N}`. Each array value knows the type of its contents `T` as well as how many dimensions `N` it has. However, since we don't know how many elements might be in an array, the computer needs to allocate memory to store the array at runtime. In terms of sets, arrays are a type contain an unbounded number of possible values.

Arrays are mutable collections - elements can be edited, inserted or deleted.

Remember that vectors and matrices are just aliases for 1D and 2D arrays.

```julia; eval = false
const Vector{T} = Array{1, T}
const Matrix{T} = Array{2, T}
```

### Strings

Strings are built into the Julia language, for convenience. They are much like a `Vector{UInt8}` containing UTF-8 encoded string data, but are immutable.

(If a future version of Julia had immutable arrays, `String` could theoretically become a "normal" Julia type, but for now this is a pragmatic tradeoff).

### ...and, that's it!

Julia provides other important types, like `Set`s and `Dict`s, but these are implemented in terms of the above. _Every_ value is one of:

 1. A primitive type
 2. A struct (immutable, mutable, tuple or named tuple)
 3. An `Array`
 4. A `String`

## Logic and syntax

Now that we've covered all the possible types of values in Julia, we'll take a look at how data is manipulated via logic and functions.

Eventually we'll come back to abstract types and multiple dispatch, but first we'll cover some fundaments of Julia code syntax and functions so we understand _what_ we are looking at later. A lot of this might be intuitive to some of you, but since we are mathematicians, we'd like to spell it out more formally :)

### Everything is an expression, everything has a value, and everything has a type

We saw earlier that an expression is a piece of code that, when evaluated, produces a value. For example:

```julia
1 + 1
```

One thing you should understand about Julia is that it uses type inference to predict the output type of an expression. 

```julia
using InteractiveUtils

@code_typed 1 + 1
```

The compiler essentially contains a "proof engine" that can formally prove constraints on the outputs of expressions. In this case it knows for sure that the output will be an `Int64`. Sometimes no proof can be found - in Julia this just makes the code slower, while in some other programming languages that could be a compilation error. This choice makes Julia feel more "dynamic" and makes prototype code easier to write.

### `if`-`else`

In Julia, _every_ piece of syntactically valid code is an expression — which means at run time it generates a value which you can assign to a variable. Even things like `if` statements!

```julia
x = 42

is_x_even = if x % 2 == 0
   "$x is even"
else
   "$x is odd"
end
```

Like many languages, Julia has a shorthand "ternary operator" (i.e. operator taking 3 inputs) for _if-else_ using `?` and `:`

```julia
is_x_even = x % 2 == 0 ? "$x is even" : "$x is odd"
```

It's worth noting these are 100% identical. We say that `x ? y : z` is "syntax sugar" for the `if` statement — it's a sweetener to make the programmer's life easier, but not an entirely new feature since you can always achieve the same thing with more characters of code. Another piece of syntax sugar is that `x + y` has exactly the same meaning as `+(x, y)`.

#### Our first abstract type

What if the types of the `true` branch and the `false` branch of `if`-`else` don't match?

```julia
is_even(x) = x % 2 == 0 ? true : "false"
```

_Q: what is the output type of `is_even`?_

```julia
is_even(2)
```

```julia
is_even(3)
```

Sometimes it's a `Bool` and sometimes it's a `String`.

```julia
@code_typed is_even(42)
```

If `Bool` represents the set containing `true` and `false`, and `String` represents the set of all possible strings, then the type `Union{Bool, String}` represents the union of these two sets.

`Union` is the first **abstract type** we'll cover, and is relatively straightforward. `Union` itself is not a concrete type; there are no values of type `Union`. It mostly exists in Julia to aid with type inference for cases like `if`-`else` above – to abstractly analyse the outputs and itermediate values of programs during compilation (where more precise inference leads to more efficient code generation). In cases like this Julia can keep track which of the two possibilities the data is in relatively efficiently (e.g. with a single byte for a tag).

There are two more ways abstract types can show up Julia that we'll see later.

#### Shortcutting logic

Julia has operators for Boolean arithmetic, including `&` for _AND_ (logical conjunction) and `|` for _OR_ (logical disjunction).

```julia
@show false & false
@show false & true
@show true & false
@show true & true
```

```julia
@show false | false
@show false | true
@show true | false
@show true | true
```

The operation `x & y` is equivalent to `&(x, y)` and will evaluate `x`, then evaluate `y` and then determine the result.

The operation `x && y` is similar but it sometimes takes a shortcut. If `x` is false, it doesn't bother compute a value for `y` (as the answer is `false` no matter the value for `y`).

This matters when `y` is particularly difficult/slow to calculate, or when it may be something you want to avoid doing when `x` is false.

Note that `x && y` is 100% equivalent to:

```julia; eval = false
if x
    y
else
    false
end
```

Note that the type of `y` doesn't even need to be `Bool`, since it is never compared to anything. Sometimes people use this in a cute way:

```julia; eval = false
x < 0 && println("x is negative")
```

People tend to use that because it takes less space to write than:

```julia; eval = false
if x < 0
    println("x is negative")
end
```

Don't feel you need to use "cute" code like this, but if you see it somewhere I don't want you to feel confused.

_Q: What does `(x < 0) & println("x is negative")` do?_

There is an equivalent shortcut operator for `|`:

```julia; eval = false
x || y
```

which is equivalent to

```julia; eval = false
if x
    true
else
    y
end
```

One "cute" way to people use this is to perform assertions:

```julia; eval = false
x >= 0 || error("x is negative")
```

### Blocks of code

Above, we saw blocks of code containing values. They didn't really _do_ anything, like assign values to variables.

The rule in Julia is that the last expression in a block of code is the value returned from that block of code. If for some reason you want to _explicitly_ create a code block (sometimes useful) you can use `begin` like so:

```julia
begin
    1
    2
    3
end
```

We see blocks of code everywhere in Julia — inside `if` and `else` statements, within `for` and `while` loops, within `function` bodies, etc. Blocks of code can be nested — we can have `if` statements inside `while` loops inside `function` bodies, and we tend to represent this visually with indentation:

```julia
function f()
    x = 0
    while x < 10
        if x % 2 == 0
            println("$x is even")
        else
            println("$x is odd")
        end
        x = x + 1
    end
    return x
end

f()
```

_Note: `for` and `while` loops always produce `nothing`!_

If you prefer, you can seperate multiple expressions in a code block with `;` instead of on seperate lines. Sometimes you'd even use parentheses to clarify where the code block begins and ends.

```julia
x = (1; 2; 3)
```

### Empty blocks of code return `nothing`

So what happens when the block of code is empty?

```julia
begin
end
```

Since every expression has a value in Julia, it must return _something_! That something is called `nothing`. It is a special builtin value that contains 0 bytes of data and has the builtin type `Nothing`.

```julia
typeof(nothing)
```

While the above is contrived, there are some more likely places to see this.

```julia
half_of_x = if x % 2 == 0
    x ÷ 2
end
```

This is _implicitly_ the same as

```julia
half_of_x = if x % 2 == 0
    x ÷ 2
else
end
```

which is _implicitly_ the same as

```julia
half_of_x = if x % 2 == 0
    x ÷ 2
else
    nothing
end
```

So if `x` is odd, then `half_of_x` is `nothing`.

We also use `nothing` as the return value for functions that don't have a value to return — e.g. when the purpose of the function is to perform some action rather that compute some value.

```julia
function hello()
    println("Hello class")
    return nothing
end

x = hello()
@show x;
```

Q: Does anyone know what the equivalent thing in _C_ is?

### Why expressions? Metaprogramming!

Having the syntax rule that "all valid syntax is an expression" makes it easier to analyse and manipulate code than it would be otherwise. It lets you rearrange code much like you can manipulate a mathematical expression with algebra (via substitution, etc), resulting in code that is correct and still compiles.

For human coders, this means it is easier to copy-paste code from one place to another, or refactor it into a function.

A "metaprogram" is a program that writes a program. Julia supports metaprogramming through macros and other advanced techniques. We won't be teaching how to create a macro, but using a macro is pretty easy. A good example is the `@show` macro:

```julia
x = 10
@show x + 1
```

Effectively the macro takes the "expression" `x + 1`, prints the expression, prints equals, and prints the evaluated value. While Julia is busy replacing the builtin syntax sugar (like operators, `x + 1`) with more fundamental expressions (like function calls, `+(x, 1)`), it also "expands" the macro, resulting in code that is roughly:

```julia
x = 10
println("x + 1 = ", x + 1)
```

Each macro can be thought of as like user-defined syntax sugar. We can extend the language with our own ideas of how we can write programs.

### An even better way to metaprogram

Another form of metaprogramming in Julia is multiple dispatch. Multiple dispatch allows us to construct entire classes of programs that depend on the _types_ of values — and Julia will construct on-demand a particular program _specialized_ on the inputs you actually provide.

Next we'll learn more about Julia functions and how multiple dispatch works. Afterwards we'll learn about abstract types and how to use this metaprogramming approach.

## Functions in Julia

Functions are at the heart of Julia, and there's lots of ways of expressing different functions. The [Julia documentation of functions](https://docs.julialang.org/en/v1/manual/functions/) provides a rich description of all of the details. We now overview a few special features that were perhaps not evident from Units 1-3. There are also links to the documentation for it.

### [Function syntaxes](https://docs.julialang.org/en/v1/manual/functions/#man-functions)

In Julia there are multiple ways of creating a function. There is the "long form":

```julia
function f1(x)
    return x^2
end
```

The `return` is optional in this case — why?

There is a "short form":

```julia
f2(x) = x^2
```

And there are "anonymous functions" (or "arrow functions"):
```julia
const f3 = x -> x^2
```

In this form `x -> x^2` is an expression that constructs a function which is "anonymous" — it has no name. We have bound it to the variable `f3` so we can use it later. You can even do this in "long form"!

```julia
const f4 = function (x)
    return x^2
end
```

(Note: the `const` isn't essential — but it will let us attach other methods to `f3` or `f4` later)

#### What type is a function?

You can think of the above functions as being a lot like `nothing` (a struct with zero fields). Each function has a unique type:

```julia
typeof(f1)
```

```julia
typeof(f2)
```

```julia
typeof(f1) == typeof(f2)
```

And like `nothing`, there is no data associated with these:

```julia
sizeof(f1)
```

These types have only one possible value, which is why Julia describes them as "singleton types". Singleton types have a one-to-one correspondence between type and value.

#### Function methods

Note that in Julia you can attach _function methods_ to any type (primitive, struct, etc), not just those defined like above.

```julia
methods(f1)
```

```julia
methods(nothing)
```

A "method" encodes the logic performed when the function executes. Types without methods are not callable. Types can have more than one method. We'll talk more about multiple methods when we discuss multiple dispatch.

For now, just know you can attach methods to _any_ type with special syntax like this:

```julia; eval = false
(x::Bool)() = "this is $x"

function (x::Bool)()
    return "this is $x"
end
```

For "singleton" types you can use the singleton value instead of the type, so these are equivalent:

```julia; eval = false
nothing() = "Nothing else matters"
(::Nothing)() = "Nothing else matters"
```

If this seems a bit crazy or abstract - don't worry! Just remember that _anything_ can be made callable - functions are not special.

### Nested functions: "closures"

In Julia you can define functions within functions.

```julia
function adder(x)
    return y -> y + x
end
```

This function returns another function! We can use the output to add things.

```julia
add_2 = adder(2)
add_2(3)
```

Such functions are called "closures" because they "close over" (or "capture") the values of variables outside their scope — in this case it captured the value of `x`, `2`, and implicitly stores it inside `add_2`.

```julia
add_2.x
```

```julia
sizeof(add_2)
```

Note again it doesn't matter which form of function syntax we use. It's just different syntax for the same thing. We could have equally written:

```julia
function adder(x)
    return function (y)
        return y + x
    end
end
```

In Julia, closures are given their own types and methods. The closure is just an automatically generated `struct` datatype with a method attached.

```julia
typeof(add_2)
```

```julia
methods(add_2)
```

Because closures are "just" a convenient way to do things you can already do in Julia with structs and methods, you can think of them as an advanced type of syntax sugar. The above is equivalent to this:

```julia
struct Adder{T}
    x::T
end

function (a::Adder)(y)
    return a.x + y
end

function adder(x)
    return Adder(x)
end

add_2 = adder(2)
```

```julia
add_2(3)
```

Note that _every_ function in Julia has its own type — e.g. `sin` and `cos` have different types. We'll come back to types and methods later.

### [Type assertions](https://docs.julialang.org/en/v1/manual/types/#Type-Declarations)

The `::` operator has two closely-related meanings.

First is type assertion. In programming an "assertion" is something the programmer asserts to be true, which either the compiler or runtime will check.

```julia
42::Int
```

You could read the above as "`42` must be an `Int`". The result is just the value — `::` doesn't normally do _anything_, unless the assertion is false

```julia
42::String
```

Julia has an "abstract" `Number` type.

```julia
42::Number
```

This is fine since `Int` is a subtype of `Number`, which itself could be written:

```julia
Int <: Number
```

(Note that this one returns `true` or `false`.)

The type `Any` is the supertype of every type.

```julia
42::Any  # always correct!
```

This type assertion always checks out, and doesn't really have any affect on your program. Therefore `x` and `x::Any` are the same thing. Such code is said to be a "no-op" because it corresponds to "no operation".

### [Argument types](https://docs.julialang.org/en/v1/manual/functions/#Argument-type-declarations)

The second meaning of `::` is in function / method signatures, which constrains the types of arguments the method will accept.

We have seen Julia methods from the start, e.g.

```julia
f(x::Int) = x^2
```

or,

```julia
f(x::Number) = x^2
```

or simply,

```julia
f(x) = x^2
```

Remember that `x` and `x::Any` are the same thing. The final method will accept _any_ inputs. Whether or not `x^2` works or throws an error depends on `x`.

In a sense, the third method isn't _safe_ since someone could provide an input like `(1, 2, 3)` that can't be squared. What happens if someone provides a string? Is this expected? On the other hand, the third method provides maximum flexibility — someone can introduce a new type that works with `f` at any point in time, without having to edit the definition of `f` to make it work.

### Dispatch

"Dispatch" is the process of determing which method of a function is called.

```julia
example_f(x::Int) = "input is an integer"
example_f(x::String) = "input is a string"

@show example_f(1)
@show example_f("abc")
@show methods(example_f)
```

You can use it to tailor the logic of a function to its inputs. Try type `methods(+)` at the REPL!

Argument types can be abstract types, like `Any` or `Union`.

```julia
example_f2(x::Int) = "input is an integer"
example_f2(x::Any) = "input is not an integer"

@show example_f2(1)
@show example_f2("abc")
@show methods(example_f2)
```

Note that `Int <: Any` and the two methods overlap somewhat. In this case Julia will pick the most "specific" method. In terms of "types as sets of values" it matches to the "smallest" set.

The term "multiple dispatch" means that dispatch can depend on the types of multiple arguments:

```julia
example_f3(x::Int, y::Int) = "both input are integers"
example_f3(x::String, y::Int) = "the inputs have different types"
example_f3(x::Int, y::String) = "the inputs have different types"
example_f3(x::String, y::String) = "both input are strings"

@show example_f3(1, 2)
@show example_f3(1, "abc")
@show methods(example_f3)
```

Note: In object-oriented languages (like Python, Javascript, C#, Java or C++) dynamic dispatch occurs only on the type of first object (the class method being called). Multiple dispatch can be a bit more flexible. 

### [Varargs functions](https://docs.julialang.org/en/v1/manual/functions/#Varargs-Functions)

Sometimes functions have a variable number of arguments — sometimes called "varargs" (or "variadic functions").

A simple thing to do might be to add up all the inputs:

```julia
function add_all(inputs...)
    out = 0
    for x in inputs
        out += x
    end
    return out
end

add_all(1, 2, 3, 4, 5)
```

```julia
function polynomialGenerator(a...)
    n = length(a) - 1
    poly = function(x)
        return sum(a[i+1] * x^i for i in 0:n)
    end
    return poly
end

polynomial = polynomialGenerator(1, 3, -10)

[polynomial(-1), polynomial(0), polynomial(1)]
```

You could use then use `Roots` package to automatically find out where all the inputs produce zero output:

```julia
using Roots

zero_vals = find_zeros(polynomial, -10, 10)
println("Zeros of the function f(x): ", zero_vals)
```

Here you start to see how Julia features like varargs functions, closures, and packages let you solve a wide range of problems without writing very much code.

### [Optional arguments](https://docs.julialang.org/en/v1/manual/functions/#Optional-Arguments)

You can have optional arguments (or default values):

```julia
using Distributions

function my_density(x::Float64, μ::Float64 = 0.0, σ::Float64 = 1.0)
    return exp(-(x-μ)^2 / (2σ^2)) / (σ*√(2π))
end

x = 1.5
@show pdf(Normal(), x), my_density(x)
@show pdf(Normal(0.5), x), my_density(x, 0.5);
```

### [Keyword arguments](https://docs.julialang.org/en/v1/manual/functions/#Keyword-Arguments)

Arguments following the `;` character in the function definition or the function call are called **keyword arguments**. These are named as they are used.

```julia
function my_density(x::Float64; μ::Float64 = 0.0, σ::Float64 = 1.0)
    return exp(-(x-μ)^2/(2σ^2) ) / (σ*√(2π)) 
end

@show pdf(Normal(0.0,2.5),x), my_density(x, σ=2.5);
```

We can even make a function that takes arbitrary numbers of positional and keyword arguments:

```julia
function very_flexible_function(args...; kwargs...)
    @show args
    @show kwargs
end

very_flexible_function(2.5, false, a=1, b="two", c=:three)
```

The standard non-keyword arguments are called "positional" arguments since they are identified by their position not their name.

Note that when _calling_ a function you may either put a `;` or a `,` before the keyword arguments. In a function definition there's an ambiguity between optional arguments and keyword

### [Destructing](https://docs.julialang.org/en/v1/manual/functions/#Argument-destructuring)

In Julia you can _destructure_ tuples (and other iterables) in the reverse way you _construct_ them:

```julia
my_tuple = (42, "abc")  # construct
(a, b) = my_tuple       # destruct

@show a
@show b;
```

A really common pattern here is swapping two variables:

```julia
x = 1
y = 2
(x, y) = (y, x)
@show x
@show y;
```

You can also destructure fields of structs and named tuples in the reverse way you create a named tuple:

```julia
function f(x::Complex)
    (; re, im) = x
    println("Real part: $re")
    println("Imaginary part: $im")
end

f(10 + 42im)
```

One thing you can do is destructure arguments to functions as they come in. For example:

```julia
f((x,y)) = x + y
my_pair = (4, 5)
f(my_pair)
```


### [Function composition and piping](https://docs.julialang.org/en/v1/manual/functions/#Function-composition-and-piping)

Just a little bit of syntax sugar for "piping" values into function calls:

```julia
π/4 |> cos |> acos |> x -> 4x
```

Here is a function just like `identity`:

```julia
const ii = cos ∘ acos #\circ + [TAB]
(ii(π/4), π/4)
```

### [Dot syntax for broadcasting functions](https://docs.julialang.org/en/v1/manual/functions/#man-vectorized)

You already know the broadcast operator. It is syntax sugar for the `broadcast` function.

```julia
x_range = 0:0.5:π
cos.(x_range)
```

See the docs for a discussion of performance of broadcasting.

You can also use the macro `@.`

```julia
x_range = 0:0.5:π
@. cos(x_range + 2)^2
```

## More items from control flow

You are already very familiar with conditional statements (`if`, `elseif`, `else`), with loops (`for` and `while`), with short circuit evaluation, and with many other variants. For example you can use `continue` and `break` in loops, and Julia even supports `@goto` and `@label` for when that isn't enough.

You can find more control flow details here: [control flow in Julia docs](https://docs.julialang.org/en/v1/manual/control-flow/). We'll just dive into `for` loops and error handling below.

### Iteration and `for` loops

One impressive piece of syntax sugar is the `for` loop. It is in fact a special case of a `while` loop, like so:

```julia; eval = false
# this loop...
for x in iterable
    # <CODE>
end

# ...is equivalent to
tmp = iterate(iterable)
while tmp !== nothing
    (x, state) = tmp

    # <CODE>
    
    tmp = iterate(iterable, state)
end
```

In the above, `tmp` is either `nothing` or it's a tuple of length two — containing the next value and whatever metadata is needed to iterate to the next element.

You can make any of your data types iterable in a `for` loop by implementing a method on the `iterate` function. We won't be doing this in this course, but it is an excellent example of an _interface_ in Julia. We'll talk more about interfaces later.

### [Errors and exceptions](https://docs.julialang.org/en/v1/manual/control-flow/#Exception-Handling)

One additional thing to know about is exception handling.

```julia
function my_2_by_2_inv(A::Matrix{Float64})
    if size(A) != (2,2)
        error("This function only works for 2x2 matrices")
    end

    d = A[1,1]*A[2,2] - A[2,1]*A[1,2]

    if d ≈ 0
        throw(ArgumentError("matrix is singular or near singular")) #\approx + [TAB]
    end

    return [A[2,2] -A[1,2]; -A[2,1] A[1,1]]/d
end

my_2_by_2_inv(rand(3,3))
```

```julia
my_2_by_2_inv([ones(2) ones(2)])
```

```julia
using LinearAlgebra

Random.seed!(0)
A = rand(2, 2)
A_inv = my_2_by_2_inv(A)
@assert A_inv*A ≈ I
```

```julia
Random.seed!(0)
for _ ∈ 1:10 #\in + [TAB]
    A = float.(rand(1:5,2,2))
    try
        my_2_by_2_inv(A)
    catch e
        println(e)
    end
end
```

An exception may be caught way down the call stack:

```julia
A = ones(2,2)
f(mat) = 10*my_2_by_2_inv(A)
g(mat) = f(mat .+ 3)
h(mat) = 2g(mat)
h(A)
```
```
ERROR: ArgumentError: matrix is singular or near singular
Stacktrace:
 [1] my_2_by_2_inv(A::Matrix{Float64})
   @ Main ~/git/mine/ProgrammingCourse-with-Julia-SimulationAnalysisAndLearningSystems/markdown/lecture-unit-4.jmd:5
 [2] f(mat::Matrix{Float64})
   @ Main ./REPL[33]:1
 [3] g(mat::Matrix{Float64})
   @ Main ./REPL[34]:1
 [4] h(mat::Matrix{Float64})
   @ Main ./REPL[35]:1
 [5] top-level scope
   @ REPL[36]:1
```

```julia
try 
    h(A)
catch e
    println(e)
end
```

#### Try, catch and finally

It's possible to catch and handle errors that happened using `try`, `catch` and `finally`.

```julia
try
    0 ÷ 0
catch e
    @show e
finally
    println("done")
end;
```

#### Resource cleanup

One place closures, and `do` syntax in particular, gets used is when you want resources to be cleaned up automatically. Here's how one method of `open` is defined in Julia:

```julia; eval = false
function open(f, filename::String)
    io = open(filename)
    try
        f(io)
    finally
        close(io)
    end
end
```

You can call the `open` function with an anonymous function like so:

```julia; eval = false
# Read the first 128 bytes from the file
open(io -> read(io, 128), filename)
```

This way even when `read` might error out (e.g. too few bytes), the file is _always_ closed in the `finally` block above. Using this pattern avoids mistakes and resource leakage.

When you want to use this pattern it is common to use `do` syntax like so:

```julia; eval = false
open(filename) do (io)
    # Read the first 128 bytes from the file
    return read(io, 128) # might throw an exception
end
```

The `do` syntax is _yet another_ way of making a function. It creates a new function and injects it into the first argument.

### Variable scope

See [variables and scoping in Julia docs](https://docs.julialang.org/en/v1/manual/variables-and-scoping/).

Julia actually has two seperate scopes — global or "toplevel" scope, and local scope.

Local scope is the simplest. Variables inside a function body take precedence (or "shadows") any variables of the same name outside the function body.

```julia
x = 0

function f()
    x = 1
    return 2 * x
end

f()
```

It gets a little more complicated when things are outside.

```julia
data = [1, 2, 3]
s = 0
β, γ = 2, 1

for i in 1:length(data)
    global s    #This usage of the `global` keyword is not needed in Jupyter
                #But elsewhere without it:
                #ERROR: LoadError: UndefVarError: s not defined
    s += β*data[i]
    data[i] *= -1 #Note that we didn't need 'global' for data
end
#print(i)       #Would cause ERROR: LoadError: UndefVarError: i not defined
@show data
@show s

function sum_data(β)
    s = 0           #try adding the prefix global
    for i in 1:length(data)
        s += β*(data[i] + γ)
    end
    return s
end
@show sum_data(β/2)
@show s
```

Julia uses Lexical scoping:

```julia
function my_function()
    x = 10
    function my_function_inside_a_function()
        @show x
    end
    return my_function_inside_a_function
end

x = 20
f_ret = my_function()
f_ret();
```

The use of `outer`:

```julia
function f()
    i = 0
    for i = 1:3
        # empty
    end
    return i
end
f()
```

```julia
function f()
    i = 0
    for outer i = 1:3
        # empty
    end
    return i
end
f()
```

My advice:

 * use global variables as little as possible
 * use distinct names for variables as much as possilbe
 * the longer a varible hangs around, the longer and more discriptive it's name should be

Remember you want your programs to be _simple_ and _easy to read_. Variable names are cheap.

## More on mutation

As we saw earlier, a type can be **mutable** or not (**immutable**). Values/objects of the immutable types are typically stored on the stack. Values/objects of mutable types are typically allocated and stored on the heap.

```julia
@show ismutable(7)
@show ismutable([7]);
```

When you pass a mutable object to a function, the function can change the data contained within.

```julia
function mutating_function(z::Array{Int}) 
    z[1] = 0
end

x = [1]
println("Before call: ", x)
mutating_function(x)
println("After call: ", x)
```

Programmers tend to need to keep track of which objects are being mutated and when. You'll see functions that mutate things often end in `!`, e.g. `push!`, `pop!`, `setindex!`, etc. This is just a convention – we could have called the above `mutating_function!`.

For immutable values, there is no way to modify their contents. They are never modified by functions.

#### Variable bindings

Variable bindings are not modified inside functions.

```julia
function rebinding_function(z::Array{Int}) 
    z = [0]
end

x = [1]
println("Before call: ", x)
mutating_function(x)
println("After call: ", x)
```

So, the rule is that you can mutate the _inside_ of a mutable value (`Array` or `mutable struct`) and _other_ variables and/or data structures with references to that mutable value will be able to see the effect of the mutation.

However variables are _always_ bound to _new_ values with `=` (e.g. `z = 0`) and the usual lexical scoping rules apply.

To help with preserving data that might get modified, we often make a copy with `copy` and `deepcopy`:

```julia
println("Immutable:")
a = 10
b = a
b = 20
@show a;
```

```julia
println("\nNo copy:")
a = [10]
b = a
b[1] = 20
@show a;
```

```julia
println("\nCopy:")
a = [10]
b = copy(a)
b[1] = 20
@show a;
```

```julia
println("\nShallow copy:")
a = [[10]]
b = copy(a)
b[1][1] = 20
@show a;
```

```julia
println("\nDeep copy:")
a = [[10]]
b = deepcopy(a)
b[1][1] = 20
@show a;
```

## Abstract type tree

We saw the `Union` abstract type earlier.

Julia also has an abstract type hierarchy (a tree). At the top of the tree is the type `Any`, which encompasses every possible value in Julia. All types have a supertype (the supertype of `Any` is `Any`). Types that are not leaves of the tree have subtypes. Some types are **abstract** while others are **concrete**. One particularly distinctive feature of Julia's type system is that concrete types may not subtype each other: all concrete types are final and may only have abstract types as their supertypes.

```julia
x = 2.3
@show typeof(x)
@show supertype(Float64)
@show supertype(AbstractFloat)
@show supertype(Real)
@show supertype(Number)
@show supertype(Any);
```

There is an **is a** relationship:
```julia
isa(2.3, Number)
```

```julia
isa(2.3, String)
```

```julia
2.3 isa Float64
```

Note that `x isa T` is the same as `typeof(x) <: T`, where we say `<:` as "is a subtype of".

```julia
@show Float64 <: Number
@show String <: Number;
```

We can ask whether a given type is abstract or concrete.

```julia
@show isabstracttype(Float64)
@show isconcretetype(Float64);
```

```julia
@show isabstracttype(Real)
@show isconcretetype(Real);
```

Structs with undefined type paremeters are not concrete:

```julia
@show isconcretetype(Complex);
```

Once we provide the type parameters we do get a concrete type:

```julia
@show isconcretetype(Complex{Float64});
```

As mentioned, Julia has a type tree. Let's walk down from `Number`:

```julia
using InteractiveUtils: subtypes

function type_and_children(type, prefix = "", child_prefix = "")
    if isconcretetype(type)
        @assert isempty(subtypes(type))

        println(prefix, type, ": concrete")
    else
        println(prefix, type, isabstracttype(type) ? ": abstract" : ": parameterized")

        children = subtypes(type)
        for (i, c) in enumerate(children)
            if i == length(children)
                type_and_children(c, "$(child_prefix) └─╴", "$(child_prefix)    ")
            else
                type_and_children(c, "$(child_prefix) ├─╴", "$(child_prefix) │  ")
            end 
        end
    end
end

type_and_children(Number)
```

In Julia, you can define abstract types with the `abstract type` keywords:

```julia; eval = false
abstract type Number
end

abstract type Real <: Number
end

abstract type AbstractFloat <: Real
end

primitive type Float64 <: AbstractFloat
    64
end
```

### Parameterized / generic types

We've actually now seen all three types of abstract types in Julia – the `abstract type`s that make up the type tree, the `Union` type, and the parameterized types (abstract `Complex` vs concrete `Complex{Float64}`).

Actually `Complex` is a shorthand. It's full type is written like this:

```julia; eval = false
Complex{T} where T <: Real
```

This object is of type `UnionAll`:

```julia
typeof(Complex)
```

You can read this like "The abstract type which is the union of the concrete types `Complex{T}` for all possible `T <: Real`" – hence the shorthand `UnionAll`. Parameterised types can have bounds, like the components of complex numbers being real numbers.

```julia
@show Complex{Float64} <: Complex
@show isconcretetype(Complex)
@show isconcretetype(Complex)
```

Julia is pretty capable at figuring out the subtype (or subset) relationships:

```julia
(Complex{T} where T <: AbstractFloat) <: Complex
```

which follow from `AbstractFloat <: Real`.

You've seen other `UnionAll` types like `Vector`, `Matrix`, `Set`, `Dict`, etc.

Don't worry about this seeming complex – consider this background material!

### Union types

We saw earlier that Julia has a third abstract type called `Union` which let's you reason about a finite set of (abstract or concrete) types.

```julia
42::Union{Int, Float64}
```

```julia
3.14::Union{Int, Float64}
```

```julia
"abc"::Union{Int, Float64}
```

`Union` can handle an arbitrary number of types, `Union{T1, T2, T3, ...}`.

As a special case `Union{T}` is just the same as `T`. We also have `Union{T, T} == T`, etc.

The union of no types at all, `Union{}`, is a special builtin type which is the opposite of `Any`. No value can exist with type `Union{}`! Sometimes `Any` is called the "top" type and `Union{}` is called the "bottom" type. It's used internally by the compiler to rule out impossible situations, but it's not something for you to worry about.

You've now seen _every possible concrete type_ and _every possible abstract type_ in all of Julia. Later when we study function methods, we'll be ready to cover multiple dispatch.

### Making types for your programs

You can define your own types. Any "serious" programming task would almost always merit that you do that.

#### Concrete `Person`

In object oriented languages (e.g. C++, Java, Python) types are typically called classes. A class (in such a language) will have both definitions of data and actions, typically called variables and methods respectively. An instance of a class would be called an object. 

Julia is not object oriented. It rather provides a different paradigm based on multiple-dispatch (which we describe below). Nevertheless, there are user defined types, called structs (structures). The name comes from C. 

```julia
struct Person # Notice the convention of using capital letters for the first letter of a struct
    height::Float64
    weight::Float64
    name::String
end

person = Person(1.79, 78.6, "Miriam") # A struct comes with a constructor function

@show typeof(person)

@show person.height # The fields of a struct are accessed via "." - not to be confused with "." used for broadcasting.
@show person.weight
@show person.name
```

```julia
@show ismutable(person)
person.weight = 85.4 # gained some weight - but this will generate and error
```

Here is a `mutable struct`

```julia
mutable struct MutablePerson
    height::Float64
    weight::Float64
    name::String
end

person = MutablePerson(1.79, 78.6, "Miriam")
person.weight = 85.4
println(person)
```

**Note:** You typically cannot redefine a type during the same Julia session. One workaround for that is to use the [Revise.jl](https://github.com/timholy/Revise.jl) package. We won't use it just yet.

```julia
struct MyStruct
    x::Int
end

struct MyStruct # Will generate an ERROR because redefining a struct
    x::Int
    y::Float64
end
```

#### Abstract `Animal`

We extends the above to a whole type hierarchy of different types of animals (including humans):

```julia
abstract type Animal end

abstract type Mammal <: Animal end
abstract type Reptile <: Animal end

struct Human <: Mammal
    height::Float64
    weight::Float64
    name::String
end    

struct Dog <: Mammal
    height::Float64
    weight::Float64
end

struct FlexDog{T <: Real} <: Mammal
    height::T
    weight::T
end

struct Crocodile <: Reptile
    length::Float64
    weight::Float64
    type::Symbol # Expect to be :salt_water or :fresh_water
end

type_and_children(Animal)
```

As stated above, the function that creates an instance of the type is called the **constructor**. Every concrete type comes with a default constructor.

```julia
methods(Crocodile)
```

```julia
tick_tock = Crocodile(2.3, 204, :salt_water)
```

You can also create other constructor methods:

```julia
function Crocodile(type::Symbol)
    if type == :salt_water
        return Crocodile(4.2, 410, :salt_water) # average male salt water croc
    elseif type == :fresh_water
        return Crocodile(2.3, 70, :fresh_water) # average male fresh water croc
    else
        error("Can't make crocodile of type $type")
    end
end

methods(Crocodile)
```

```julia
Crocodile(:salt_water) 
```

```julia
Crocodile(:fresh_water) 
```

```julia
Crocodile(:ice_water) # will generate an error
```

A bit more on [constructors](https://docs.julialang.org/en/v1/manual/constructors/) will come later.

Notice we had the [parameteric type](https://docs.julialang.org/en/v1/manual/types/#Parametric-Types) `FlexDog`:

```julia
dash_my_dog = FlexDog(2, 4)
@show typeof(dash_my_dog)

lassy_your_dog = FlexDog(2.3f0, 5.7f0)
@show typeof(lassy_your_dog)

my_dog_array = FlexDog{UInt16}[]
```

```julia
my_dog_array = FlexDog{Complex}[] # Will not work because Complex is not a Real
```

With multiple dispatch we can get a form of polymorphism:

```julia
animal_noise(animal::Dog) = "woof"
animal_noise(animal::Human) = "hello"
animal_noise(animal::Crocodile) = "chchch"

animals = [Crocodile(:fresh_water), Human(1.79, 78.6, "Miriam"), Crocodile(:salt_water), Dog(0.63, 12.5)]
animal_noise.(animals)
```

```julia
methods(animal_noise)
```

We can even handle the `FlexDog` and `Dog` together:

```julia
animal_noise(animal::Union{Dog, FlexDog}) = "woof"
push!(animals, FlexDog{Int16}(2,4))
animal_noise.(animals)
```

We can now say that `animal_noise` is a part of the `Animal` interface. Every `animal::Animal` will have an `animal_noise(animal)` which is returns a `String`. This is a guarantee people can use to build programs about `Animal`s.

#### The `Animal` interface

Most interestingly - at any point users could come along and define new types of `Animal`, and so long as the respect the interface the new types will function in pre-existing programs that did not anticipate them.

```julia
# sometime later...
struct Cat <: Mammal
    height::Float64
    weight::Float64
end

animal_noise(::Cat) = "meow"
```

Using interfaces lets you build larger programs by assembling _generic_ logic with different data types like they were Lego bricks. Generic code can be reused - it doesn't need to be rewritten when a new type is added, or a when new field is added to a struct, or when a new interface is introduced.

Interfaces are flexible in two ways — you can add new types of `Animal` or of `AbstractArray`, or you think up new interfaces to `Animal` or add new interfaces to `AbstractArray` (e.g. `LinearAlgebra`).

## Methods and Multiple Dispatch

[See methods in Julia docs](https://docs.julialang.org/en/v1/manual/methods/).

If there is one key attribute to Julia it is **multiple dispatch** as we have just seen above. 

```julia
function my_f(x::Int)
    println("My integer is $x")
end

function my_f(x::Float64)
    println("My floating point number is $x")
end

@show my_f(2)
@show my_f(2.5)
@show methods(my_f);
```

It is worthwhile to watch this [video](https://www.youtube.com/watch?v=kc9HwsxE1OY) about the philosphy of multiple dispatch. Some of the content of the video may be a bit advanced, but perhaps towards the end of the course it would be worth listening to it again to see what makes sense and what not yet.

### Specificity

When a function has multiple methods on it, Julia will automatically use the most specific one:

```julia
function my_f(x::Number)
    println("My number is $x")
end

my_f(2)
my_f(2.5)
my_f(2 // 3)

println()
@show methods(my_f);
```

Dispatch always uses the _concrete types_ of the input values to find the correct method. This might mean it doesn't actually compile your code until the middle of program execution. (The Julia runtime includes the compiler itself).

### Defining more methods for existing functions

Almost any operation in julia is a function. For example,

```julia
using InteractiveUtils

@which 2 + 3
```

There are many methods for `+`:

```julia
methods(+) |> length
```

So what if we had our own type and wanted to have `+` for it, and say an integer.

```julia
struct PlayerScore
    player_name::String
    score::Int
end

me = PlayerScore("Johnny", 22)
```

```julia
me = me + 10 # will generate an error since `+` for me and an integer is not defined
```

So let's define it:

```julia
import Base: + # we do this to let Julia know we will add more methods to `+`

function +(ps::PlayerScore, n::Int)::PlayerScore
    return PlayerScore(ps.player_name, ps.score + n)
end

me = me + 10
```

You can do this for every operation and function you want (and makes sense).  What if we wanted "pretty printing"?

```julia
import Base: show

show(io::IO, ps::PlayerScore) = print(io, "Score for $(ps.player_name) = $(ps.score)")

println("We have a some score: $me. Pretty good!")
```

### Example: online statistics

Lets consider an example where we want to collect some quick running statistics from some data coming in. E.g.:

```julia
using Random, Statistics

# A function that returns a data point - could be streamed from disk or the internet
fetch_new_data() = 100*rand()

function print_running_stats(n::Integer, running_stats_storage)
    for i in 1:n
        # Get some data
        data_point = fetch_new_data()

        # Collect data for statistics
        push!(running_stats_storage, data_point)

        # Peridoically we look at summary statistics
        if i % 20 == 0
            println("-------")
            println("Count: ", length(running_stats_storage))
            println("Mean: ", mean(running_stats_storage))
            println("Max: ", maximum(running_stats_storage))
        end
    end
end

Random.seed!(0)
running_stats_storage = Float64[] # Some place to hold the running data
print_running_stats(100, running_stats_storage)
```

Consider the scenario where you have a lot of data to stream and `n` gets very big... so you don't want to recompute the mean and max every time. In fact — you might not even want to store the a copy of the data in RAM at all!

Here's an approach to do "online" statistics:

```julia
mutable struct RunningStats
    count::Int
    sum::Float64
    max::Float64

    RunningStats() = new(0, 0.0, -Inf)
end

running_stats_storage = RunningStats()
```

We can now make specific methods for `push!`, `length`, `sum`, `mean` and `maximum` for this new type:

```julia
import Base: push!, length, sum, maximum
import Statistics: mean

length(rsd::RunningStats) = rsd.count
sum(rsd::RunningStats) = rsd.sum
mean(rsd::RunningStats) = rsd.sum / rsd.count
maximum(rsd::RunningStats) = rsd.max

function push!(rsd::RunningStats, data_point)
    # Update the count
    rsd.count += 1

    # Update the sum
    rsd.sum += data_point

    # Update the maximum
    if rsd.max < data_point
        rsd.max = data_point
    end
end

Random.seed!(0)
running_stats_storage = RunningStats()
print_running_stats(100, running_stats_storage)
```

#### Running statistics of other types

Going a bit more generic we could have also had,

```julia
mutable struct FlexRunningStats{T <: Number}
    data::Vector{T}
    count::Int
    sum::T
    max::T

    FlexRunningStats{T}() where {T} = new{T}(T[], 0, zero(T), typemin(T))
end

length(rsd::FlexRunningStats) = rsd.count
sum(rsd::FlexRunningStats) = rsd.sum
mean(rsd::FlexRunningStats) = rsd.sum / rsd.count
maximum(rsd::FlexRunningStats) = rsd.max

function push!(rsd::FlexRunningStats, data_point)
    # Insert the new datapoint
    push!(rsd.data, data_point)

    # Update the count
    rsd.count += 1

    # Update the sum
    rsd.sum += data_point

    # Update the maximum
    if rsd.max < data_point
        rsd.max = data_point
    end
end

fetch_new_data() = rand(0:10^4) # override this to return integers

Random.seed!(0)
running_stats_storage = FlexRunningStats{Int}()
print_running_stats(100, running_stats_storage)
```

```julia
@which mean(running_stats_storage)
```

But there is a problem with the above. What if `T` was `Complex`? Should we have done `<: Number` or `<: Real`?

In generic code its good to consider what *interfaces* we want to use, so we can figure out which type constraints are appropriate. Julia will go ahead and assemble the peices of your program together into a coherent whole. 

### Interfaces

So above we used a few interface methods to implement our online-statistics accumulator.

 * `push!` - add an element to a collection (mutates the input)
 * `length` - the number of element in a collection
 * `sum` - add up all the element in a collection
 * `maximum` - the maximum number of elements in a collection
 * `mean` - the mean of all the elements in a collection

Let's have a look at some common interfaces

#### Numbers

 * Common arithmetic operations `+`, `-`, `*`, `/`, etc.
 * `promote(x, y)` - take two numbers and return two numbers of the same type, e.g `promote_type(3.14, 1) = (3.14, 1.0)`
 * `promote_rule(T1, T2)` - e.g. `promote_rule(Float64, Int64) = Float64`.

Some subtypes of `Number` like `AbstractFloat` have more interface methods.

#### Iterables

* `iterate(iter)` - used in `for` loops
* `length(iter)` - the number of elements to iterate
* `eltype(iter)` - the type of the elements to iterate

Some things iterate but we might not have known length or element type, so there you can define some *traits* to describe these facts:

* `IteratorSize(iter)` - return whether `length` is known
* `IteratorEltype(iter)` - return whether `eltype` is known

#### Arrays

Arrays are iterable and satisfy the the above. They are also indexable

* `getindex(a, i)` - the function behind `a[i]`
* `setindex!(a, v, i)` - the function behind `a[i] = v`
* `size(a)` - gives a tuple of sizes, e.g. `size([1,2,3]) = (3,)`

In fact you can create a custom array in Julia with just those methods above! Things like ranges `1:10` are subtypes of `AbstractArray`.

Some types like `Vector` are resizable and for these types there are functions like `push!`, `pop!`, `insert!`, `deleteat!`, `append!`, `empty!`, etc to manipulate them as arbitrary-sized lists.

Arrays are also defined as arithmetic objects according to linear algebra, and therefore have `+`, `-`, `*`, `/`, etc defined. The `LinearAlgebra` standard library package has lots of functions to invert or decompose matrices, find eigenvalues, etc.

#### Sets

Julia has a `Set{T}` type and an `AbstractSet{T}` supertype. Sets are iterable and support things like:

 * `in`
 * `union`
 * `intersect`
 * `setdiff`
 * `symdiff`

Here's where interfaces get interesting. Things like `Array` also support `in`, but it is slow (must check every element). With `Set` lookup is fast (e.g. O(1) instead of O(N)) - so the operations above are fast.

#### Dictionaries

Julia has a `Dict{K, T}` type and an `AbstractDict{K, T}` supertype. Like arrays, dictionaries are iterable and indexable. You can imagine they are like a `Set` but have associate values (in fact their implementation is related).

 * `keys(dict)` - return the set of keys
 * `haskey(dict, key)` - check if a key exists in the dictionary
 * `getindex(dict, key)` - get a value associated with a key
 * `setindex!(dict, value, key)` - insert or update a key
 * `delete!(dict, key)` - remove a key
 * `keytype(dict)` - the type of the dictionary keys
 * `valtype(dict)` - the type of the dictionary values

You generally iterate a dictionary by specifying if you want to iterate the keys, values, or both:

 * `pairs(dict)` - an iterable of `key => value` pairs (the default)
 * `keys(dict)` - an iterable of the dictionary keys only
 * `values(dict)` - an iterable of the dictionary values only

### Using structs for complex, nested data structures

You can make interesting data structures by referencing other instances of yourself, like this tree structure below:

```julia
Random.seed!(0)

struct Node
    id::UInt16
    friends::Vector{Node}
    Node() = new(rand(UInt16), [])
    Node(friend::Node) = new(rand(UInt16),[friend])
end

"""
Makes 'n` children to node, each with a single friend
"""
function make_children(node::Node, n::Int, friend::Node)
    for _ in 1:n
        new_node = Node(friend)
        push!(node.friends, new_node)
    end
end

root = Node()
make_children(root, 3, root)
for node in root.friends
    make_children(node, 2,root)
end
root
```

### More to be covered as part of Unit 6:

[See constructors in Julia docs](https://docs.julialang.org/en/v1/manual/constructors/). More on this in Unit 6.

[See conversion and promotion in Julia docs](https://docs.julialang.org/en/v1/manual/conversion-and-promotion/)

[See interfaces in Julia docs](https://docs.julialang.org/en/v1/manual/interfaces/)