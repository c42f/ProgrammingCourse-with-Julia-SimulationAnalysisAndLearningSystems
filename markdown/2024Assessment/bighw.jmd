# BigHW - Semester 2, 2024.
(last edit: July 19, 2024)

**Due:** August 30, 2024, 16:00. This assignment is in pairs.

Here will be an **explainer video** for this assignment.

**Note:** Since this assignment is in **pairs** make sure to submit with the names of both partners (or all three in exceptional circumstances) as well as student numbers. Submission will be via the Blackboard account of **only one** of the teammates but will count equally for both (or all three). All cases that involve a group of a single person or three people in the team, require **explicit permission** from the course coordinator.

The recommended way to work in **pairs** is to have a **lead** for each question and a **reviewer** for each **question**. The leader will be responsible that a solution is created and the reviewer will be consulted and provide feedback. In previous years students that were not exposed to all questions ended up doing more poorly in the course quiz in comparison to students that reviewed (or led) all questions. There is certainly no need to state who is the lead and who is the reviewer for the questions. Ultimately the pair is jointly responsible for the assignment submission. 

**Submission format:**  The submission format is via a GitHub repository as described in Question 10. The submission should include the four submissions forms [I](https://github.com/yoninazarathy/ProgrammingCourse-with-Julia-SimulationAnalysisAndLearningSystems/blob/main/submission_forms_jupyter/Submission-Form-I-Q1-Q4.ipynb), [II](https://github.com/yoninazarathy/ProgrammingCourse-with-Julia-SimulationAnalysisAndLearningSystems/blob/main/submission_forms_jupyter/Submission-Form-II-Q5-Q9.ipynb), [III](https://github.com/yoninazarathy/ProgrammingCourse-with-Julia-SimulationAnalysisAndLearningSystems/blob/main/submission_forms_jupyter/Submission-Form-III-Q10-Q12.ipynb), and [IV](https://github.com/yoninazarathy/ProgrammingCourse-with-Julia-SimulationAnalysisAndLearningSystems/blob/main/submission_forms_jupyter/Submission-Form-IV-Q13-Q17.ipynb). 

The submission should also include an audio recording (30 sec minimum, 3 minutes maximum, 1 minute recommended). The voice recording should have voices of both (all) members of the group. The recording should verify that the work is your own. You can also state how you felt in the assignment. Say what was easy, what was hard, what you found useful, and what less. In case you used LLMs (chat-GPT etc...), make sure to mention how you used it and where it was useful (or not).

To submit, go to Blackboard and submit as instructed there by providing a link to the GitHub repo, naming the partners, and uploading the voice recording (do not upload the voice recording to GitHub - upload it to Blackboard). PDFs of the Jupyter notebooks and voice recordings are for Blackboard. Jupyter notebooks are for GitHub.

**Marking Criteria:** 

* 4 points are allocated for following instructions. This includes proper submission of the voice recording, the `.ipynb` file(s), having names and student numbers on the hand-in, and most importantly neatly formatting all the answers of the jupyter notebook.

* There are 16 questions in total, with 6 points allocated for each question. Some questions are easier and some harder. Some require more work and some require less work.

* There is an additional bonus question, question 17, dealing with Dr. Megan Dawson's perspective seminar. It yields an additional 10 bonus points. 

* As this is the first assignment, points will not be deducted for sloppy coding style. However, in future assignments clean and consistent coding style is required.

--- 

# Questions 1--4 are submitted on Jupyter notebook I 


## Question 1: LaTeX, Jupyter, HTML, and Markdown

This question deals with basic formatting tools.

**1a**: Consider the following recursive integration by parts formula for integer $n \ge 1$:

$$
\int_0^\infty x^n  ~ e^{-x}  ~ dx 
= 
-\underbrace{x^{n} e^{-x}\Big|^\infty_0}_0   ~~+~~  n \int_0^\infty x^{n-1} ~ e^{-x}  dx.
$$

Use LaTeX to represent this formula for $n=2$ by repeating the integration by parts twice. 

**1b**: Use Markdown to write an ordered list of 5 programming languages, where you mention for each language where it is used. For example Javascript is often used for front end web development (but not limited to that), etc.

**1c**: Use HTML to embed an image with an hyperlink from the image. Use HTML to resize the image to a size you like. Make sure the aspect ratio is maintained.

## Question 2: Warming up with quadratic equations 

The following function uses the quadratic formula to compute the real roots of the quadratic equation $ax^2 + bx + c = 0$. The return value is an array with 0, 1, or 2 roots. 

```julia
function real_roots_of_quadratic(a::Number, b::Number, c::Number)

    #Start by initializing an empty array
    roots::Array{Float64} = []

    #Compute the discriminant 
    Δ = b^2 - 4a*c #\Delta + [TAB]

    #Based on the sign of the discriminant return 0, 1, or 2 roots.
    if Δ < 0 
        roots = []
    elseif Δ == 0
        roots = [-b/(2a)]
    else
        roots = [-b + √Δ, -b - √Δ] / (2a) #\sqrt + [TAB]
    end
    return roots 
end

#Attempting on -x²+5x-6=0
real_roots_of_quadratic(-1,5,-6)
```

**2a**: Experiment with multiple syntax variations by making a modification to the code snippet above and in each case observing the outcome. 

1. The function accepts three arguments, `a`, `b`, and `c`. They are each of type `Number` as specified via `::Number`. Would the code still work without the `::Number` type specification? (yes/no). Try to explain why.
2. Observe that the expression for the discriminant uses `4a*c` as short hand for `4*a*c`. Would `4ac` work? (yes/no). Try to explain why.
3. A common typo in programming is to use `=` in place of `==`. The former is an assignment operator and the later is a logical operator checking for equality. Insert this typo by replacing `Δ == 0` with `Δ = 0`. Do you get a syntax error or a logical program error?
4. The expression `[-b + √Δ, -b - √Δ] / (2a)` can also be written as `(-b .+ [√Δ,-√Δ])/(2a)`. Check this, does it work? (yes/no). Now do it with using `+` in the new expression instead of `.+`. Does it still work? (yes/no) Try to explain why.
5. The `return` statement in the line `return roots` is optional yet makes for more verbose code. Try removing `return`. Does the function still work? (yes/no). 
6. There is a certain set of inputs for which this function will not work. Try setting the input argument `a` as `0` or `0.0`. What is the result?
7. To handle such cases where the quadratic equation is actually "not quadratic" add error checking code at the top of the function. One way to do this is to return some error message for example add at the top of the function: 
```
if a == 0
    return "Error - this is not a quadratic equation"
end
```
Check that this works.
8. Instead of adding these three lines you may also shorten them as,
```
a == 0 && return "Error - this is not a quadratic equation"
```
Check that this works and try to figure out (and explain) what this does.
9. Finally instead of returning a string as an error, we may use a more advanced mechanism. So use this instead:
```
a == 0 && throw(DomainError(a, "argument must be nonzero"))
```
You will discuss such exception handling in Unit 4, yet at this point try to do your best to explain what this does.


**2b**: Now that we have a function that find the real roots of such quadratic equations, let us try it on a few examples:

```julia
examples = [[1,-5,6], [1,2,3],[1,7,0]]

for example in examples
    roots = real_roots_of_quadratic(example[1], example[2], example[3])
    print("The equation $(example[1])x² + $(example[2])x + $(example[3]) = 0 ") #\^2 + [TAB] #***
    if length(roots) == 0 #***
        println("has no real roots.") #***
    elseif length(roots) == 1 #***
        println("has the single (real) root $(roots[1])") #***
    else #***
        println("has the real roots $(roots[1]) and $(roots[2])") #***
    end #***
end
```

1. Add two more examples of your own to the array (of arrays) `examples` and see how it works.
2. The lines marked with `#***` could have been set in a function of their own and that function can be called (invoked) in place of those lines. Name that function `print_quadratic_roots()` and have it accept two arguments. The first argument is an array `coefficients` which is interpreted as the coefficients ($a$, $b$, and $c$). The second argument is the array `roots`. Define that function and run the code with your new function in place of the lines marked with `#***`. Since your new function does not have a return value you may write `return nothing` in the end.
3. Finally beautify the output of your function such that when a coefficient is $+1$ or $-1$ it is not printed but rather only the sign is printed (if needed). For example the polynomial $-1x^2-1x+1$ is better printed as $-x^2-x+1$. In doing so, use the [ternary operator](https://docs.julialang.org/en/v1/manual/control-flow/#man-conditional-evaluation) `? :`. In one way or another. This may have code with less lines (less explicit big `if` - `else` statements).

**2c**: It is common and useful to create testing code that checks that operational code works. For the function `real_roots_of_quadratic()` we may create another function as follows:

```julia
using Random
"""
This function generates `num_tests` random triples of coefficients and checks that the function `real_roots_of_quadratic()` does its job. The return value is `true` if the test passed, otherwise it is `false`.
"""
function test_real_roots_of_quadratic(;num_tests = 10000, seed=42)
    Random.seed!(seed)
    test_passed = true
    for _ in 1:num_tests
        a, b, c = 2000rand(3) .- 1000 #uniform values in the range [-1000, 1000]
        roots = real_roots_of_quadratic(a,b,c)
        for x in roots
            err = a*x^2 + b*x + c 
            test_passed = (test_passed && isapprox(err, 0.0, atol = 1e-8)) 
        end
    end
    return test_passed
end

test_real_roots_of_quadratic() ? println("Test passed") : println("Test failed")
```

1. Work on understanding the expression `2000rand(3) .- 1000`. How would you change this expression if you wanted the coefficients to be in the range [-5,5]? Make that change and see if the test still passes. (yes/no).
1. Instead of having the numbers `2000` and `1000` "hardcoded" in the function it is better practice to pass them as optional arguments, similarly to the arguments `num_tests` and `seed`. Do this by creating arguments `coeff_min` and `coeff_max` that are by default at `-1000` and `1000` respectively. This means that the values in the expression `2000rand(3) .- 1000` need to be represented in terms of these arguments. Do this.
1. What happens in this test when there are no real roots? How many iterations does the for loop execute in this case? 
1. In general a test passing is only a necessary condition for validity of a program rather than a sufficient condition. Can you suggest some sort of bug in the `real_roots_of_quadratic()` function that can exist which would slip through the test? Try this bug (modify `real_roots_of_quadratic()` and show that the test still passes).
1. A different way to test would be to use "random roots" instead of random coefficients. Such a test would first randomly decide if there are 0 real roots, 1 real root, or 2 real roots. It would then randomly draw the roots. It would then find the coefficients that match these roots. It would then test that `real_roots_of_quadratic()` has these roots. Try to implement such a test function. For the case of 0 (real roots) you may "hardcode" a few specific examples. Alternatively (optional) try to use the complex numbers. For example `rand()+rand()*im` is a complex number with random real and imaginary values, each in [0,1]

**2d**: In general, we may have had a solver that finds the (potentially) complex roots of a quadratic. Since the coefficients, $a$, $b$, and $c$ are real, these are complex conjugates. So we want to use the quadratic formula directly (potentially taking square roots of negative numbers). 

Trying:

```julia
√(-4) #\sqrt + [TAB] is like the sqrt() function
```

We got an error. Instead we need to highlight that `-4` is a complex number:

```julia
Complex(-4) #Create a complex number -4 + 0i 
```

Now the `sqrt()` function, which we shorten via the √ symbol works:

```julia
√Complex(-4) #This is \sqrt + [TAB], just like sqrt()
```

So we can now create:

```julia
function roots_of_quadratic(a::Number, b::Number, c::Number)
    roots::Array{ComplexF64} = []
    Δ = b^2 - 4a*c
    if Δ < 0 
        roots = [-b + √Complex(Δ), -b - √Complex(Δ)] / (2a)
    elseif Δ == 0
        roots = -b/(2a)
    else
        roots = [-b + √Δ, -b - √Δ] / (2a) 
    end
    return roots 
end

roots_of_quadratic(1,2,3)
```

The above implementation is fine, however it has code duplication for both cases of $\Delta \neq 0$. That is the case `Δ < 0` and the case `Δ > 0` can be merged. Modify the function so that it does not have an `elseif` statement. In fact, try to write the function without any `if` statement but rather only using the trinary operator `? :`. 

## Question 3: A little case of Faulhaber's formula

REPLACE

[Faulhaber's formula](https://en.wikipedia.org/wiki/Faulhaber%27s_formula) presents an expression for 

$$
\sum_{i=1}^n i^p,
$$
where $p$ is some non-negative integer. This problem deals with the case of $p=5$ and to solve this problem you don't need to investigate Faulhaber's formula.

Say you believe that the expression resulting from the formula for $p=5$ is:

$$
\sum_{i=1}^{n} i^5 = \frac{1}{6} n^6 + \frac{1}{2} n^5 + \frac{5}{12} n^4 - \frac{5}{60} n^2,
$$

but just to be sure you want to write a program that checks this for $20$ random values (repetitions allowed) of $n$ in the range of $1,\ldots,10^3$. 

**3a**: Write short program that performs this check by comparing the formula calculation and a calculation using a loop.

**3b**: Now try to use a variant of the program to do the check for $n=10^4$. Does it work? If not try to explain why?

**3c**: Now use Julia's `big()` function to do the calculation with `BigInt` types and use `//` to represent the fraction coefficients as rational types. Can you get an exact match now? 
